{"ast":null,"code":"'use strict';\n\nconst url = require('url');\nconst https = require('https');\nconst WebPushError = require('./web-push-error.js');\nconst vapidHelper = require('./vapid-helper.js');\nconst encryptionHelper = require('./encryption-helper.js');\nconst webPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\nlet gcmAPIKey = '';\nlet vapidDetails;\nfunction WebPushLib() {}\n\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */\nWebPushLib.prototype.setGCMAPIKey = function (apiKey) {\n  if (apiKey === null) {\n    gcmAPIKey = null;\n    return;\n  }\n  if (typeof apiKey === 'undefined' || typeof apiKey !== 'string' || apiKey.length === 0) {\n    throw new Error('The GCM API Key should be a non-empty string or null.');\n  }\n  gcmAPIKey = apiKey;\n};\n\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */\nWebPushLib.prototype.setVapidDetails = function (subject, publicKey, privateKey) {\n  if (arguments.length === 1 && arguments[0] === null) {\n    vapidDetails = null;\n    return;\n  }\n  vapidHelper.validateSubject(subject);\n  vapidHelper.validatePublicKey(publicKey);\n  vapidHelper.validatePrivateKey(privateKey);\n  vapidDetails = {\n    subject: subject,\n    publicKey: publicKey,\n    privateKey: privateKey\n  };\n};\n\n/**\n * To get the details of a request to trigger a push message, without sending\n * a push notification call this method.\n *\n * This method will throw an error if there is an issue with the input.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Object}                       This method returns an Object which\n * contains 'endpoint', 'method', 'headers' and 'payload'.\n */\nWebPushLib.prototype.generateRequestDetails = function (subscription, payload, options) {\n  if (!subscription || !subscription.endpoint) {\n    throw new Error('You must pass in a subscription with at least ' + 'an endpoint.');\n  }\n  if (typeof subscription.endpoint !== 'string' || subscription.endpoint.length === 0) {\n    throw new Error('The subscription endpoint must be a string with ' + 'a valid URL.');\n  }\n  if (payload) {\n    // Validate the subscription keys\n    if (typeof subscription !== 'object' || !subscription.keys || !subscription.keys.p256dh || !subscription.keys.auth) {\n      throw new Error('To send a message with a payload, the ' + 'subscription must have \\'auth\\' and \\'p256dh\\' keys.');\n    }\n  }\n  let currentGCMAPIKey = gcmAPIKey;\n  let currentVapidDetails = vapidDetails;\n  let timeToLive = DEFAULT_TTL;\n  let extraHeaders = {};\n  let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n  let urgency = webPushConstants.supportedUrgency.NORMAL;\n  let topic;\n  let proxy;\n  let agent;\n  let timeout;\n  if (options) {\n    const validOptionKeys = ['headers', 'gcmAPIKey', 'vapidDetails', 'TTL', 'contentEncoding', 'urgency', 'topic', 'proxy', 'agent', 'timeout'];\n    const optionKeys = Object.keys(options);\n    for (let i = 0; i < optionKeys.length; i += 1) {\n      const optionKey = optionKeys[i];\n      if (!validOptionKeys.includes(optionKey)) {\n        throw new Error('\\'' + optionKey + '\\' is an invalid option. ' + 'The valid options are [\\'' + validOptionKeys.join('\\', \\'') + '\\'].');\n      }\n    }\n    if (options.headers) {\n      extraHeaders = options.headers;\n      let duplicates = Object.keys(extraHeaders).filter(function (header) {\n        return typeof options[header] !== 'undefined';\n      });\n      if (duplicates.length > 0) {\n        throw new Error('Duplicated headers defined [' + duplicates.join(',') + ']. Please either define the header in the' + 'top level options OR in the \\'headers\\' key.');\n      }\n    }\n    if (options.gcmAPIKey) {\n      currentGCMAPIKey = options.gcmAPIKey;\n    }\n\n    // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n    if (options.vapidDetails !== undefined) {\n      currentVapidDetails = options.vapidDetails;\n    }\n    if (options.TTL !== undefined) {\n      timeToLive = Number(options.TTL);\n      if (timeToLive < 0) {\n        throw new Error('TTL should be a number and should be at least 0');\n      }\n    }\n    if (options.contentEncoding) {\n      if (options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        contentEncoding = options.contentEncoding;\n      } else {\n        throw new Error('Unsupported content encoding specified.');\n      }\n    }\n    if (options.urgency) {\n      if (options.urgency === webPushConstants.supportedUrgency.VERY_LOW || options.urgency === webPushConstants.supportedUrgency.LOW || options.urgency === webPushConstants.supportedUrgency.NORMAL || options.urgency === webPushConstants.supportedUrgency.HIGH) {\n        urgency = options.urgency;\n      } else {\n        throw new Error('Unsupported urgency specified.');\n      }\n    }\n    if (options.topic) {\n      if (!urlBase64Helper.validate(options.topic)) {\n        throw new Error('Unsupported characters set use the URL or filename-safe Base64 characters set');\n      }\n      if (options.topic.length > 32) {\n        throw new Error('use maximum of 32 characters from the URL or filename-safe Base64 characters set');\n      }\n      topic = options.topic;\n    }\n    if (options.proxy) {\n      if (typeof options.proxy === 'string' || typeof options.proxy.host === 'string') {\n        proxy = options.proxy;\n      } else {\n        console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');\n      }\n    }\n    if (options.agent) {\n      if (options.agent instanceof https.Agent) {\n        if (proxy) {\n          console.warn('Agent option will be ignored because proxy option is defined.');\n        }\n        agent = options.agent;\n      } else {\n        console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');\n      }\n    }\n    if (typeof options.timeout === 'number') {\n      timeout = options.timeout;\n    }\n  }\n  if (typeof timeToLive === 'undefined') {\n    timeToLive = DEFAULT_TTL;\n  }\n  const requestDetails = {\n    method: 'POST',\n    headers: {\n      TTL: timeToLive\n    }\n  };\n  Object.keys(extraHeaders).forEach(function (header) {\n    requestDetails.headers[header] = extraHeaders[header];\n  });\n  let requestPayload = null;\n  if (payload) {\n    const encrypted = encryptionHelper.encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n    requestDetails.headers['Content-Length'] = encrypted.cipherText.length;\n    requestDetails.headers['Content-Type'] = 'application/octet-stream';\n    if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n      requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n      requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_GCM;\n      requestDetails.headers.Encryption = 'salt=' + encrypted.salt;\n      requestDetails.headers['Crypto-Key'] = 'dh=' + encrypted.localPublicKey.toString('base64url');\n    }\n    requestPayload = encrypted.cipherText;\n  } else {\n    requestDetails.headers['Content-Length'] = 0;\n  }\n  const isGCM = subscription.endpoint.startsWith('https://android.googleapis.com/gcm/send');\n  const isFCM = subscription.endpoint.startsWith('https://fcm.googleapis.com/fcm/send');\n  // VAPID isn't supported by GCM hence the if, else if.\n  if (isGCM) {\n    if (!currentGCMAPIKey) {\n      console.warn('Attempt to send push notification to GCM endpoint, ' + 'but no GCM key is defined. Please use setGCMApiKey() or add ' + '\\'gcmAPIKey\\' as an option.');\n    } else {\n      requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n    }\n  } else if (currentVapidDetails) {\n    const parsedUrl = url.parse(subscription.endpoint);\n    const audience = parsedUrl.protocol + '//' + parsedUrl.host;\n    const vapidHeaders = vapidHelper.getVapidHeaders(audience, currentVapidDetails.subject, currentVapidDetails.publicKey, currentVapidDetails.privateKey, contentEncoding);\n    requestDetails.headers.Authorization = vapidHeaders.Authorization;\n    if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n      if (requestDetails.headers['Crypto-Key']) {\n        requestDetails.headers['Crypto-Key'] += ';' + vapidHeaders['Crypto-Key'];\n      } else {\n        requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];\n      }\n    }\n  } else if (isFCM && currentGCMAPIKey) {\n    requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n  }\n  requestDetails.headers.Urgency = urgency;\n  if (topic) {\n    requestDetails.headers.Topic = topic;\n  }\n  requestDetails.body = requestPayload;\n  requestDetails.endpoint = subscription.endpoint;\n  if (proxy) {\n    requestDetails.proxy = proxy;\n  }\n  if (agent) {\n    requestDetails.agent = agent;\n  }\n  if (timeout) {\n    requestDetails.timeout = timeout;\n  }\n  return requestDetails;\n};\n\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */\nWebPushLib.prototype.sendNotification = function (subscription, payload, options) {\n  let requestDetails;\n  try {\n    requestDetails = this.generateRequestDetails(subscription, payload, options);\n  } catch (err) {\n    return Promise.reject(err);\n  }\n  return new Promise(function (resolve, reject) {\n    const httpsOptions = {};\n    const urlParts = url.parse(requestDetails.endpoint);\n    httpsOptions.hostname = urlParts.hostname;\n    httpsOptions.port = urlParts.port;\n    httpsOptions.path = urlParts.path;\n    httpsOptions.headers = requestDetails.headers;\n    httpsOptions.method = requestDetails.method;\n    if (requestDetails.timeout) {\n      httpsOptions.timeout = requestDetails.timeout;\n    }\n    if (requestDetails.agent) {\n      httpsOptions.agent = requestDetails.agent;\n    }\n    if (requestDetails.proxy) {\n      const {\n        HttpsProxyAgent\n      } = require('https-proxy-agent'); // eslint-disable-line global-require\n      httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n    }\n    const pushRequest = https.request(httpsOptions, function (pushResponse) {\n      let responseText = '';\n      pushResponse.on('data', function (chunk) {\n        responseText += chunk;\n      });\n      pushResponse.on('end', function () {\n        if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n          reject(new WebPushError('Received unexpected response code', pushResponse.statusCode, pushResponse.headers, responseText, requestDetails.endpoint));\n        } else {\n          resolve({\n            statusCode: pushResponse.statusCode,\n            body: responseText,\n            headers: pushResponse.headers\n          });\n        }\n      });\n    });\n    if (requestDetails.timeout) {\n      pushRequest.on('timeout', function () {\n        pushRequest.destroy(new Error('Socket timeout'));\n      });\n    }\n    pushRequest.on('error', function (e) {\n      reject(e);\n    });\n    if (requestDetails.body) {\n      pushRequest.write(requestDetails.body);\n    }\n    pushRequest.end();\n  });\n};\nmodule.exports = WebPushLib;","map":{"version":3,"names":["url","require","https","WebPushError","vapidHelper","encryptionHelper","webPushConstants","urlBase64Helper","DEFAULT_TTL","gcmAPIKey","vapidDetails","WebPushLib","prototype","setGCMAPIKey","apiKey","length","Error","setVapidDetails","subject","publicKey","privateKey","arguments","validateSubject","validatePublicKey","validatePrivateKey","generateRequestDetails","subscription","payload","options","endpoint","keys","p256dh","auth","currentGCMAPIKey","currentVapidDetails","timeToLive","extraHeaders","contentEncoding","supportedContentEncodings","AES_128_GCM","urgency","supportedUrgency","NORMAL","topic","proxy","agent","timeout","validOptionKeys","optionKeys","Object","i","optionKey","includes","join","headers","duplicates","filter","header","undefined","TTL","Number","AES_GCM","VERY_LOW","LOW","HIGH","validate","host","console","warn","Agent","requestDetails","method","forEach","requestPayload","encrypted","encrypt","cipherText","Encryption","salt","localPublicKey","toString","isGCM","startsWith","isFCM","Authorization","parsedUrl","parse","audience","protocol","vapidHeaders","getVapidHeaders","Urgency","Topic","body","sendNotification","err","Promise","reject","resolve","httpsOptions","urlParts","hostname","port","path","HttpsProxyAgent","pushRequest","request","pushResponse","responseText","on","chunk","statusCode","destroy","e","write","end","module","exports"],"sources":["/var/www/html/react-chat-app/firebase-chat-app/node_modules/web-push/src/web-push-lib.js"],"sourcesContent":["'use strict';\n\nconst url = require('url');\nconst https = require('https');\n\nconst WebPushError = require('./web-push-error.js');\nconst vapidHelper = require('./vapid-helper.js');\nconst encryptionHelper = require('./encryption-helper.js');\nconst webPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n// Default TTL is four weeks.\nconst DEFAULT_TTL = 2419200;\n\nlet gcmAPIKey = '';\nlet vapidDetails;\n\nfunction WebPushLib() {\n\n}\n\n/**\n * When sending messages to a GCM endpoint you need to set the GCM API key\n * by either calling setGMAPIKey() or passing in the API key as an option\n * to sendNotification().\n * @param  {string} apiKey The API key to send with the GCM request.\n */\nWebPushLib.prototype.setGCMAPIKey = function(apiKey) {\n  if (apiKey === null) {\n    gcmAPIKey = null;\n    return;\n  }\n\n  if (typeof apiKey === 'undefined'\n  || typeof apiKey !== 'string'\n  || apiKey.length === 0) {\n    throw new Error('The GCM API Key should be a non-empty string or null.');\n  }\n\n  gcmAPIKey = apiKey;\n};\n\n/**\n * When making requests where you want to define VAPID details, call this\n * method before sendNotification() or pass in the details and options to\n * sendNotification.\n * @param  {string} subject    This must be either a URL or a 'mailto:'\n * address. For example: 'https://my-site.com/contact' or\n * 'mailto: contact@my-site.com'\n * @param  {string} publicKey  The public VAPID key, a URL safe, base64 encoded string\n * @param  {string} privateKey The private VAPID key, a URL safe, base64 encoded string.\n */\nWebPushLib.prototype.setVapidDetails = function(subject, publicKey, privateKey) {\n    if (arguments.length === 1 && arguments[0] === null) {\n      vapidDetails = null;\n      return;\n    }\n\n    vapidHelper.validateSubject(subject);\n    vapidHelper.validatePublicKey(publicKey);\n    vapidHelper.validatePrivateKey(privateKey);\n\n    vapidDetails = {\n      subject: subject,\n      publicKey: publicKey,\n      privateKey: privateKey\n    };\n  };\n\n  /**\n   * To get the details of a request to trigger a push message, without sending\n   * a push notification call this method.\n   *\n   * This method will throw an error if there is an issue with the input.\n   * @param  {PushSubscription} subscription The PushSubscription you wish to\n   * send the notification to.\n   * @param  {string|Buffer} [payload]       The payload you wish to send to the\n   * the user.\n   * @param  {Object} [options]              Options for the GCM API key and\n   * vapid keys can be passed in if they are unique for each notification you\n   * wish to send.\n   * @return {Object}                       This method returns an Object which\n   * contains 'endpoint', 'method', 'headers' and 'payload'.\n   */\nWebPushLib.prototype.generateRequestDetails = function(subscription, payload, options) {\n    if (!subscription || !subscription.endpoint) {\n      throw new Error('You must pass in a subscription with at least '\n      + 'an endpoint.');\n    }\n\n    if (typeof subscription.endpoint !== 'string'\n    || subscription.endpoint.length === 0) {\n      throw new Error('The subscription endpoint must be a string with '\n      + 'a valid URL.');\n    }\n\n    if (payload) {\n      // Validate the subscription keys\n      if (typeof subscription !== 'object' || !subscription.keys\n      || !subscription.keys.p256dh\n      || !subscription.keys.auth) {\n        throw new Error('To send a message with a payload, the '\n        + 'subscription must have \\'auth\\' and \\'p256dh\\' keys.');\n      }\n    }\n\n    let currentGCMAPIKey = gcmAPIKey;\n    let currentVapidDetails = vapidDetails;\n    let timeToLive = DEFAULT_TTL;\n    let extraHeaders = {};\n    let contentEncoding = webPushConstants.supportedContentEncodings.AES_128_GCM;\n    let urgency = webPushConstants.supportedUrgency.NORMAL;\n    let topic;\n    let proxy;\n    let agent;\n    let timeout;\n\n    if (options) {\n      const validOptionKeys = [\n        'headers',\n        'gcmAPIKey',\n        'vapidDetails',\n        'TTL',\n        'contentEncoding',\n        'urgency',\n        'topic',\n        'proxy',\n        'agent',\n        'timeout'\n      ];\n      const optionKeys = Object.keys(options);\n      for (let i = 0; i < optionKeys.length; i += 1) {\n        const optionKey = optionKeys[i];\n        if (!validOptionKeys.includes(optionKey)) {\n          throw new Error('\\'' + optionKey + '\\' is an invalid option. '\n          + 'The valid options are [\\'' + validOptionKeys.join('\\', \\'')\n          + '\\'].');\n        }\n      }\n\n      if (options.headers) {\n        extraHeaders = options.headers;\n        let duplicates = Object.keys(extraHeaders)\n            .filter(function (header) {\n              return typeof options[header] !== 'undefined';\n            });\n\n        if (duplicates.length > 0) {\n          throw new Error('Duplicated headers defined ['\n          + duplicates.join(',') + ']. Please either define the header in the'\n          + 'top level options OR in the \\'headers\\' key.');\n        }\n      }\n\n      if (options.gcmAPIKey) {\n        currentGCMAPIKey = options.gcmAPIKey;\n      }\n\n      // Falsy values are allowed here so one can skip Vapid `else if` below and use FCM\n      if (options.vapidDetails !== undefined) {\n        currentVapidDetails = options.vapidDetails;\n      }\n\n      if (options.TTL !== undefined) {\n        timeToLive = Number(options.TTL);\n        if (timeToLive < 0) {\n          throw new Error('TTL should be a number and should be at least 0');\n        }\n      }\n\n      if (options.contentEncoding) {\n        if ((options.contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM\n          || options.contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM)) {\n          contentEncoding = options.contentEncoding;\n        } else {\n          throw new Error('Unsupported content encoding specified.');\n        }\n      }\n\n      if (options.urgency) {\n        if ((options.urgency === webPushConstants.supportedUrgency.VERY_LOW\n          || options.urgency === webPushConstants.supportedUrgency.LOW\n          || options.urgency === webPushConstants.supportedUrgency.NORMAL\n          || options.urgency === webPushConstants.supportedUrgency.HIGH)) {\n          urgency = options.urgency;\n        } else {\n          throw new Error('Unsupported urgency specified.');\n        }\n      }\n\n      if (options.topic) {\n        if (!urlBase64Helper.validate(options.topic)) {\n          throw new Error('Unsupported characters set use the URL or filename-safe Base64 characters set');\n        }\n        if (options.topic.length > 32) {\n          throw new Error('use maximum of 32 characters from the URL or filename-safe Base64 characters set');\n        }\n        topic = options.topic;\n      }\n\n      if (options.proxy) {\n        if (typeof options.proxy === 'string'\n          || typeof options.proxy.host === 'string') {\n          proxy = options.proxy;\n        } else {\n          console.warn('Attempt to use proxy option, but invalid type it should be a string or proxy options object.');\n        }\n      }\n\n      if (options.agent) {\n        if (options.agent instanceof https.Agent) {\n          if (proxy) {\n            console.warn('Agent option will be ignored because proxy option is defined.');\n          }\n\n          agent = options.agent;\n        } else {\n          console.warn('Wrong type for the agent option, it should be an instance of https.Agent.');\n        }\n      }\n\n      if (typeof options.timeout === 'number') {\n        timeout = options.timeout;\n      }\n    }\n\n    if (typeof timeToLive === 'undefined') {\n      timeToLive = DEFAULT_TTL;\n    }\n\n    const requestDetails = {\n      method: 'POST',\n      headers: {\n        TTL: timeToLive\n      }\n    };\n    Object.keys(extraHeaders).forEach(function (header) {\n      requestDetails.headers[header] = extraHeaders[header];\n    });\n    let requestPayload = null;\n\n    if (payload) {\n      const encrypted = encryptionHelper\n        .encrypt(subscription.keys.p256dh, subscription.keys.auth, payload, contentEncoding);\n\n      requestDetails.headers['Content-Length'] = encrypted.cipherText.length;\n      requestDetails.headers['Content-Type'] = 'application/octet-stream';\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_128_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_128_GCM;\n      } else if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        requestDetails.headers['Content-Encoding'] = webPushConstants.supportedContentEncodings.AES_GCM;\n        requestDetails.headers.Encryption = 'salt=' + encrypted.salt;\n        requestDetails.headers['Crypto-Key'] = 'dh=' + encrypted.localPublicKey.toString('base64url');\n      }\n\n      requestPayload = encrypted.cipherText;\n    } else {\n      requestDetails.headers['Content-Length'] = 0;\n    }\n\n    const isGCM = subscription.endpoint.startsWith('https://android.googleapis.com/gcm/send');\n    const isFCM = subscription.endpoint.startsWith('https://fcm.googleapis.com/fcm/send');\n    // VAPID isn't supported by GCM hence the if, else if.\n    if (isGCM) {\n      if (!currentGCMAPIKey) {\n        console.warn('Attempt to send push notification to GCM endpoint, '\n        + 'but no GCM key is defined. Please use setGCMApiKey() or add '\n        + '\\'gcmAPIKey\\' as an option.');\n      } else {\n        requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n      }\n    } else if (currentVapidDetails) {\n      const parsedUrl = url.parse(subscription.endpoint);\n      const audience = parsedUrl.protocol + '//'\n      + parsedUrl.host;\n\n      const vapidHeaders = vapidHelper.getVapidHeaders(\n        audience,\n        currentVapidDetails.subject,\n        currentVapidDetails.publicKey,\n        currentVapidDetails.privateKey,\n        contentEncoding\n      );\n\n      requestDetails.headers.Authorization = vapidHeaders.Authorization;\n\n      if (contentEncoding === webPushConstants.supportedContentEncodings.AES_GCM) {\n        if (requestDetails.headers['Crypto-Key']) {\n          requestDetails.headers['Crypto-Key'] += ';'\n          + vapidHeaders['Crypto-Key'];\n        } else {\n          requestDetails.headers['Crypto-Key'] = vapidHeaders['Crypto-Key'];\n        }\n      }\n    } else if (isFCM && currentGCMAPIKey) {\n      requestDetails.headers.Authorization = 'key=' + currentGCMAPIKey;\n    }\n\n    requestDetails.headers.Urgency = urgency;\n\n    if (topic) {\n      requestDetails.headers.Topic = topic;\n    }\n\n    requestDetails.body = requestPayload;\n    requestDetails.endpoint = subscription.endpoint;\n\n    if (proxy) {\n      requestDetails.proxy = proxy;\n    }\n\n    if (agent) {\n      requestDetails.agent = agent;\n    }\n\n    if (timeout) {\n      requestDetails.timeout = timeout;\n    }\n\n    return requestDetails;\n  };\n\n/**\n * To send a push notification call this method with a subscription, optional\n * payload and any options.\n * @param  {PushSubscription} subscription The PushSubscription you wish to\n * send the notification to.\n * @param  {string|Buffer} [payload]       The payload you wish to send to the\n * the user.\n * @param  {Object} [options]              Options for the GCM API key and\n * vapid keys can be passed in if they are unique for each notification you\n * wish to send.\n * @return {Promise}                       This method returns a Promise which\n * resolves if the sending of the notification was successful, otherwise it\n * rejects.\n */\nWebPushLib.prototype.sendNotification = function(subscription, payload, options) {\n    let requestDetails;\n    try {\n      requestDetails = this.generateRequestDetails(subscription, payload, options);\n    } catch (err) {\n      return Promise.reject(err);\n    }\n\n    return new Promise(function(resolve, reject) {\n      const httpsOptions = {};\n      const urlParts = url.parse(requestDetails.endpoint);\n      httpsOptions.hostname = urlParts.hostname;\n      httpsOptions.port = urlParts.port;\n      httpsOptions.path = urlParts.path;\n\n      httpsOptions.headers = requestDetails.headers;\n      httpsOptions.method = requestDetails.method;\n\n      if (requestDetails.timeout) {\n        httpsOptions.timeout = requestDetails.timeout;\n      }\n\n      if (requestDetails.agent) {\n        httpsOptions.agent = requestDetails.agent;\n      }\n\n      if (requestDetails.proxy) {\n        const { HttpsProxyAgent } = require('https-proxy-agent'); // eslint-disable-line global-require\n        httpsOptions.agent = new HttpsProxyAgent(requestDetails.proxy);\n      }\n\n      const pushRequest = https.request(httpsOptions, function(pushResponse) {\n        let responseText = '';\n\n        pushResponse.on('data', function(chunk) {\n          responseText += chunk;\n        });\n\n        pushResponse.on('end', function() {\n          if (pushResponse.statusCode < 200 || pushResponse.statusCode > 299) {\n            reject(new WebPushError(\n              'Received unexpected response code',\n              pushResponse.statusCode,\n              pushResponse.headers,\n              responseText,\n              requestDetails.endpoint\n            ));\n          } else {\n            resolve({\n              statusCode: pushResponse.statusCode,\n              body: responseText,\n              headers: pushResponse.headers\n            });\n          }\n        });\n      });\n\n      if (requestDetails.timeout) {\n        pushRequest.on('timeout', function() {\n          pushRequest.destroy(new Error('Socket timeout'));\n        });\n      }\n\n      pushRequest.on('error', function(e) {\n        reject(e);\n      });\n\n      if (requestDetails.body) {\n        pushRequest.write(requestDetails.body);\n      }\n\n      pushRequest.end();\n    });\n  };\n\nmodule.exports = WebPushLib;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}