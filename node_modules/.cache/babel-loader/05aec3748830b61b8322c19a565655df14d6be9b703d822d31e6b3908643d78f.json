{"ast":null,"code":"'use strict';\n\nconst crypto = require('crypto');\nconst asn1 = require('asn1.js');\nconst jws = require('jws');\nconst {\n  URL\n} = require('url');\nconst WebPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */\nconst DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function () {\n  this.seq().obj(this.key('version').int(), this.key('privateKey').octstr(), this.key('parameters').explicit(0).objid().optional(), this.key('publicKey').explicit(1).bitstr().optional());\n});\nfunction toPEM(key) {\n  return ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key,\n    parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1\n  }, 'pem', {\n    label: 'EC PRIVATE KEY'\n  });\n}\nfunction generateVAPIDKeys() {\n  const curve = crypto.createECDH('prime256v1');\n  curve.generateKeys();\n  let publicKeyBuffer = curve.getPublicKey();\n  let privateKeyBuffer = curve.getPrivateKey();\n\n  // Occassionally the keys will not be padded to the correct lengh resulting\n  // in errors, hence this padding.\n  // See https://github.com/web-push-libs/web-push/issues/295 for history.\n  if (privateKeyBuffer.length < 32) {\n    const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n    padding.fill(0);\n    privateKeyBuffer = Buffer.concat([padding, privateKeyBuffer]);\n  }\n  if (publicKeyBuffer.length < 65) {\n    const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n    padding.fill(0);\n    publicKeyBuffer = Buffer.concat([padding, publicKeyBuffer]);\n  }\n  return {\n    publicKey: publicKeyBuffer.toString('base64url'),\n    privateKey: privateKeyBuffer.toString('base64url')\n  };\n}\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('No subject set in vapidDetails.subject.');\n  }\n  if (typeof subject !== 'string' || subject.length === 0) {\n    throw new Error('The subject value must be a string containing an https: URL or ' + 'mailto: address. ' + subject);\n  }\n  let subjectParseResult = null;\n  try {\n    subjectParseResult = new URL(subject);\n  } catch (err) {\n    throw new Error('Vapid subject is not a valid URL. ' + subject);\n  }\n  if (!['https:', 'mailto:'].includes(subjectParseResult.protocol)) {\n    throw new Error('Vapid subject is not an https: or mailto: URL. ' + subject);\n  }\n  if (subjectParseResult.hostname === 'localhost') {\n    console.warn('Vapid subject points to a localhost web URI, which is unsupported by ' + 'Apple\\'s push notification server and will result in a BadJwtToken error when ' + 'sending notifications.');\n  }\n}\nfunction validatePublicKey(publicKey) {\n  if (!publicKey) {\n    throw new Error('No key set vapidDetails.publicKey');\n  }\n  if (typeof publicKey !== 'string') {\n    throw new Error('Vapid public key is must be a URL safe Base 64 ' + 'encoded string.');\n  }\n  if (!urlBase64Helper.validate(publicKey)) {\n    throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n  }\n  publicKey = Buffer.from(publicKey, 'base64url');\n  if (publicKey.length !== 65) {\n    throw new Error('Vapid public key should be 65 bytes long when decoded.');\n  }\n}\nfunction validatePrivateKey(privateKey) {\n  if (!privateKey) {\n    throw new Error('No key set in vapidDetails.privateKey');\n  }\n  if (typeof privateKey !== 'string') {\n    throw new Error('Vapid private key must be a URL safe Base 64 ' + 'encoded string.');\n  }\n  if (!urlBase64Helper.validate(privateKey)) {\n    throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n  }\n  privateKey = Buffer.from(privateKey, 'base64url');\n  if (privateKey.length !== 32) {\n    throw new Error('Vapid private key should be 32 bytes long when decoded.');\n  }\n}\n\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */\nfunction getFutureExpirationTimestamp(numSeconds) {\n  const futureExp = new Date();\n  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n  return Math.floor(futureExp.getTime() / 1000);\n}\n\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */\nfunction validateExpiration(expiration) {\n  if (!Number.isInteger(expiration)) {\n    throw new Error('`expiration` value must be a number');\n  }\n  if (expiration < 0) {\n    throw new Error('`expiration` must be a positive integer');\n  }\n\n  // Roughly checks the time of expiration, since the max expiration can be ahead\n  // of the time than at the moment the expiration was generated\n  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n  if (expiration >= maxExpirationTimestamp) {\n    throw new Error('`expiration` value is greater than maximum of 24 hours');\n  }\n}\n\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */\nfunction getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n  if (!audience) {\n    throw new Error('No audience could be generated for VAPID.');\n  }\n  if (typeof audience !== 'string' || audience.length === 0) {\n    throw new Error('The audience value must be a string containing the ' + 'origin of a push service. ' + audience);\n  }\n  try {\n    new URL(audience); // eslint-disable-line no-new\n  } catch (err) {\n    throw new Error('VAPID audience is not a url. ' + audience);\n  }\n  validateSubject(subject);\n  validatePublicKey(publicKey);\n  validatePrivateKey(privateKey);\n  privateKey = Buffer.from(privateKey, 'base64url');\n  if (expiration) {\n    validateExpiration(expiration);\n  } else {\n    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n  }\n  const header = {\n    typ: 'JWT',\n    alg: 'ES256'\n  };\n  const jwtPayload = {\n    aud: audience,\n    exp: expiration,\n    sub: subject\n  };\n  const jwt = jws.sign({\n    header: header,\n    payload: jwtPayload,\n    privateKey: toPEM(privateKey)\n  });\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n    return {\n      Authorization: 'vapid t=' + jwt + ', k=' + publicKey\n    };\n  }\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n    return {\n      Authorization: 'WebPush ' + jwt,\n      'Crypto-Key': 'p256ecdsa=' + publicKey\n    };\n  }\n  throw new Error('Unsupported encoding type specified.');\n}\nmodule.exports = {\n  generateVAPIDKeys: generateVAPIDKeys,\n  getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n  getVapidHeaders: getVapidHeaders,\n  validateSubject: validateSubject,\n  validatePublicKey: validatePublicKey,\n  validatePrivateKey: validatePrivateKey,\n  validateExpiration: validateExpiration\n};","map":{"version":3,"names":["crypto","require","asn1","jws","URL","WebPushConstants","urlBase64Helper","DEFAULT_EXPIRATION_SECONDS","MAX_EXPIRATION_SECONDS","ECPrivateKeyASN","define","seq","obj","key","int","octstr","explicit","objid","optional","bitstr","toPEM","encode","version","privateKey","parameters","label","generateVAPIDKeys","curve","createECDH","generateKeys","publicKeyBuffer","getPublicKey","privateKeyBuffer","getPrivateKey","length","padding","Buffer","alloc","fill","concat","publicKey","toString","validateSubject","subject","Error","subjectParseResult","err","includes","protocol","hostname","console","warn","validatePublicKey","validate","from","validatePrivateKey","getFutureExpirationTimestamp","numSeconds","futureExp","Date","setSeconds","getSeconds","Math","floor","getTime","validateExpiration","expiration","Number","isInteger","maxExpirationTimestamp","getVapidHeaders","audience","contentEncoding","header","typ","alg","jwtPayload","aud","exp","sub","jwt","sign","payload","supportedContentEncodings","AES_128_GCM","Authorization","AES_GCM","module","exports"],"sources":["/var/www/html/react-chat-app/firebase-chat-app/node_modules/web-push/src/vapid-helper.js"],"sourcesContent":["'use strict';\n\nconst crypto = require('crypto');\nconst asn1 = require('asn1.js');\nconst jws = require('jws');\nconst { URL } = require('url');\n\nconst WebPushConstants = require('./web-push-constants.js');\nconst urlBase64Helper = require('./urlsafe-base64-helper');\n\n/**\n * DEFAULT_EXPIRATION is set to seconds in 12 hours\n */\nconst DEFAULT_EXPIRATION_SECONDS = 12 * 60 * 60;\n\n// Maximum expiration is 24 hours according. (See VAPID spec)\nconst MAX_EXPIRATION_SECONDS = 24 * 60 * 60;\n\nconst ECPrivateKeyASN = asn1.define('ECPrivateKey', function() {\n  this.seq().obj(\n    this.key('version').int(),\n    this.key('privateKey').octstr(),\n    this.key('parameters').explicit(0).objid()\n      .optional(),\n    this.key('publicKey').explicit(1).bitstr()\n      .optional()\n  );\n});\n\nfunction toPEM(key) {\n  return ECPrivateKeyASN.encode({\n    version: 1,\n    privateKey: key,\n    parameters: [1, 2, 840, 10045, 3, 1, 7] // prime256v1\n  }, 'pem', {\n    label: 'EC PRIVATE KEY'\n  });\n}\n\nfunction generateVAPIDKeys() {\n  const curve = crypto.createECDH('prime256v1');\n  curve.generateKeys();\n\n  let publicKeyBuffer = curve.getPublicKey();\n  let privateKeyBuffer = curve.getPrivateKey();\n\n  // Occassionally the keys will not be padded to the correct lengh resulting\n  // in errors, hence this padding.\n  // See https://github.com/web-push-libs/web-push/issues/295 for history.\n  if (privateKeyBuffer.length < 32) {\n    const padding = Buffer.alloc(32 - privateKeyBuffer.length);\n    padding.fill(0);\n    privateKeyBuffer = Buffer.concat([padding, privateKeyBuffer]);\n  }\n\n  if (publicKeyBuffer.length < 65) {\n    const padding = Buffer.alloc(65 - publicKeyBuffer.length);\n    padding.fill(0);\n    publicKeyBuffer = Buffer.concat([padding, publicKeyBuffer]);\n  }\n\n  return {\n    publicKey: publicKeyBuffer.toString('base64url'),\n    privateKey: privateKeyBuffer.toString('base64url')\n  };\n}\n\nfunction validateSubject(subject) {\n  if (!subject) {\n    throw new Error('No subject set in vapidDetails.subject.');\n  }\n\n  if (typeof subject !== 'string' || subject.length === 0) {\n    throw new Error('The subject value must be a string containing an https: URL or '\n    + 'mailto: address. ' + subject);\n  }\n\n  let subjectParseResult = null;\n  try {\n    subjectParseResult = new URL(subject);\n  } catch (err) {\n    throw new Error('Vapid subject is not a valid URL. ' + subject);\n  }\n  if (!['https:', 'mailto:'].includes(subjectParseResult.protocol)) {\n    throw new Error('Vapid subject is not an https: or mailto: URL. ' + subject);\n  }\n  if (subjectParseResult.hostname === 'localhost') {\n    console.warn('Vapid subject points to a localhost web URI, which is unsupported by '\n      + 'Apple\\'s push notification server and will result in a BadJwtToken error when '\n      + 'sending notifications.');\n    }\n}\n\nfunction validatePublicKey(publicKey) {\n  if (!publicKey) {\n    throw new Error('No key set vapidDetails.publicKey');\n  }\n\n  if (typeof publicKey !== 'string') {\n    throw new Error('Vapid public key is must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(publicKey)) {\n    throw new Error('Vapid public key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  publicKey = Buffer.from(publicKey, 'base64url');\n\n  if (publicKey.length !== 65) {\n    throw new Error('Vapid public key should be 65 bytes long when decoded.');\n  }\n}\n\nfunction validatePrivateKey(privateKey) {\n  if (!privateKey) {\n    throw new Error('No key set in vapidDetails.privateKey');\n  }\n\n  if (typeof privateKey !== 'string') {\n    throw new Error('Vapid private key must be a URL safe Base 64 '\n    + 'encoded string.');\n  }\n\n  if (!urlBase64Helper.validate(privateKey)) {\n    throw new Error('Vapid private key must be a URL safe Base 64 (without \"=\")');\n  }\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (privateKey.length !== 32) {\n    throw new Error('Vapid private key should be 32 bytes long when decoded.');\n  }\n}\n\n/**\n * Given the number of seconds calculates\n * the expiration in the future by adding the passed `numSeconds`\n * with the current seconds from Unix Epoch\n *\n * @param {Number} numSeconds Number of seconds to be added\n * @return {Number} Future expiration in seconds\n */\nfunction getFutureExpirationTimestamp(numSeconds) {\n  const futureExp = new Date();\n  futureExp.setSeconds(futureExp.getSeconds() + numSeconds);\n  return Math.floor(futureExp.getTime() / 1000);\n}\n\n/**\n * Validates the Expiration Header based on the VAPID Spec\n * Throws error of type `Error` if the expiration is not validated\n *\n * @param {Number} expiration Expiration seconds from Epoch to be validated\n */\nfunction validateExpiration(expiration) {\n  if (!Number.isInteger(expiration)) {\n    throw new Error('`expiration` value must be a number');\n  }\n\n  if (expiration < 0) {\n    throw new Error('`expiration` must be a positive integer');\n  }\n\n  // Roughly checks the time of expiration, since the max expiration can be ahead\n  // of the time than at the moment the expiration was generated\n  const maxExpirationTimestamp = getFutureExpirationTimestamp(MAX_EXPIRATION_SECONDS);\n\n  if (expiration >= maxExpirationTimestamp) {\n    throw new Error('`expiration` value is greater than maximum of 24 hours');\n  }\n}\n\n/**\n * This method takes the required VAPID parameters and returns the required\n * header to be added to a Web Push Protocol Request.\n * @param  {string} audience        This must be the origin of the push service.\n * @param  {string} subject         This should be a URL or a 'mailto:' email\n * address.\n * @param  {string} publicKey       The VAPID public key.\n * @param  {string} privateKey      The VAPID private key.\n * @param  {string} contentEncoding The contentEncoding type.\n * @param  {integer} [expiration]   The expiration of the VAPID JWT.\n * @return {Object}                 Returns an Object with the Authorization and\n * 'Crypto-Key' values to be used as headers.\n */\nfunction getVapidHeaders(audience, subject, publicKey, privateKey, contentEncoding, expiration) {\n  if (!audience) {\n    throw new Error('No audience could be generated for VAPID.');\n  }\n\n  if (typeof audience !== 'string' || audience.length === 0) {\n    throw new Error('The audience value must be a string containing the '\n    + 'origin of a push service. ' + audience);\n  }\n\n  try {\n    new URL(audience); // eslint-disable-line no-new\n  } catch (err) {\n    throw new Error('VAPID audience is not a url. ' + audience);\n  }\n\n  validateSubject(subject);\n  validatePublicKey(publicKey);\n  validatePrivateKey(privateKey);\n\n  privateKey = Buffer.from(privateKey, 'base64url');\n\n  if (expiration) {\n    validateExpiration(expiration);\n  } else {\n    expiration = getFutureExpirationTimestamp(DEFAULT_EXPIRATION_SECONDS);\n  }\n\n  const header = {\n    typ: 'JWT',\n    alg: 'ES256'\n  };\n\n  const jwtPayload = {\n    aud: audience,\n    exp: expiration,\n    sub: subject\n  };\n\n  const jwt = jws.sign({\n    header: header,\n    payload: jwtPayload,\n    privateKey: toPEM(privateKey)\n  });\n\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_128_GCM) {\n    return {\n      Authorization: 'vapid t=' + jwt + ', k=' + publicKey\n    };\n  }\n  if (contentEncoding === WebPushConstants.supportedContentEncodings.AES_GCM) {\n    return {\n      Authorization: 'WebPush ' + jwt,\n      'Crypto-Key': 'p256ecdsa=' + publicKey\n    };\n  }\n\n  throw new Error('Unsupported encoding type specified.');\n}\n\nmodule.exports = {\n  generateVAPIDKeys: generateVAPIDKeys,\n  getFutureExpirationTimestamp: getFutureExpirationTimestamp,\n  getVapidHeaders: getVapidHeaders,\n  validateSubject: validateSubject,\n  validatePublicKey: validatePublicKey,\n  validatePrivateKey: validatePrivateKey,\n  validateExpiration: validateExpiration\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}