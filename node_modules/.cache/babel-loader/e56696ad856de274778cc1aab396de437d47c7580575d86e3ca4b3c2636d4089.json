{"ast":null,"code":"'use strict';\n\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\nvar crypto = require('crypto');\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = {\n  'aes128gcm': 1,\n  'aesgcm': 2\n};\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function (m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function (m, k) {\n    return k;\n  };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n  return keylog('expand', output.slice(0, l));\n}\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\nfunction info(base, context) {\n  var result = Buffer.concat([Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'), context]);\n  keylog('info ' + base, result);\n  return result;\n}\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT + ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([Buffer.from(header.keylabel, 'ascii'), Buffer.from([0]), lengthPrefix(receiverPubKey),\n    // user agent\n    lengthPrefix(senderPubKey) // application server\n    ])\n  };\n}\nfunction extractSecretAndContext(header, mode) {\n  var result = {\n    secret: null,\n    context: Buffer.alloc(0)\n  };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) {\n    // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret, info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT + ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh', HKDF(header.authSecret, header.privateKey.computeSecret(remotePubKey), Buffer.concat([Buffer.from('WebPush: info\\0'), receiverPubKey, senderPubKey]), SHA_256_LENGTH));\n}\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function');\n    }\n  }\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid);\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n  return webpushSecret(header, mode);\n}\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) + ((m / 0x1000000 ^ counter / 0x1000000) & 0xffffff) * 0x1000000;\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while (i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end), header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {\n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << padSize * 8) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end), recordPad, header, last);\n    result = Buffer.concat([result, block]);\n    start = end;\n    ++counter;\n  }\n  return result;\n}\nfunction isFunction(object) {\n  return typeof object === 'function';\n}\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};","map":{"version":3,"names":["crypto","require","AES_GCM","PAD_SIZE","TAG_LENGTH","KEY_LENGTH","NONCE_LENGTH","SHA_256_LENGTH","MODE_ENCRYPT","MODE_DECRYPT","keylog","process","env","ECE_KEYLOG","m","k","console","warn","length","toString","decode","b","Buffer","from","HMAC_hash","key","input","hmac","createHmac","update","digest","HKDF_extract","salt","ikm","HKDF_expand","prk","info","l","output","alloc","T","counter","cbuf","writeUIntBE","concat","slice","HKDF","len","base","context","result","lengthPrefix","buffer","extractDH","header","mode","privateKey","senderPubKey","receiverPubKey","getPublicKey","dh","Error","secret","computeSecret","keylabel","extractSecretAndContext","keyid","undefined","keymap","authSecret","webpushSecret","remotePubKey","extractSecret","keyLookupCallback","isFunction","deriveKeyAndNonce","lookupKeyCallback","version","keyInfo","nonceInfo","s","nonce","parseParams","params","rs","parseInt","isNaN","overhead","generateNonce","readUIntBE","x","readHeader","idsz","unpadLegacy","data","padSize","pad","padCheck","fill","compare","unpad","last","i","decryptRecord","gcm","createDecipheriv","setAuthTag","final","decrypt","headerLength","start","chunkSize","end","Math","min","block","encryptRecord","createCipheriv","ciphertext","padding","push","tag","getAuthTag","writeHeader","ints","encrypt","isBuffer","randomBytes","recordPad","object","module","exports"],"sources":["/var/www/html/react-chat-app/firebase-chat-app/node_modules/http_ece/ece.js"],"sourcesContent":["'use strict';\n/*\n * Encrypted content coding\n *\n * === Note about versions ===\n *\n * This code supports multiple versions of the draft.  This is selected using\n * the |version| parameter.\n *\n * aes128gcm: The most recent version, the salt, record size and key identifier\n *    are included in a header that is part of the encrypted content coding.\n *\n * aesgcm: The version that is widely deployed with WebPush (as of 2016-11).\n *    This version is selected by default, unless you specify a |padSize| of 1.\n */\n\nvar crypto = require('crypto');\n\nvar AES_GCM = 'aes-128-gcm';\nvar PAD_SIZE = { 'aes128gcm': 1, 'aesgcm': 2 };\nvar TAG_LENGTH = 16;\nvar KEY_LENGTH = 16;\nvar NONCE_LENGTH = 12;\nvar SHA_256_LENGTH = 32;\nvar MODE_ENCRYPT = 'encrypt';\nvar MODE_DECRYPT = 'decrypt';\n\nvar keylog;\nif (process.env.ECE_KEYLOG === '1') {\n  keylog = function(m, k) {\n    console.warn(m + ' [' + k.length + ']: ' + k.toString('base64url'));\n    return k;\n  };\n} else {\n  keylog = function(m, k) { return k; };\n}\n\n/* Optionally base64 decode something. */\nfunction decode(b) {\n  if (typeof b === 'string') {\n    return Buffer.from(b, 'base64url');\n  }\n  return b;\n}\n\nfunction HMAC_hash(key, input) {\n  var hmac = crypto.createHmac('sha256', key);\n  hmac.update(input);\n  return hmac.digest();\n}\n\n/* HKDF as defined in RFC5869, using SHA-256 */\nfunction HKDF_extract(salt, ikm) {\n  keylog('salt', salt);\n  keylog('ikm', ikm);\n  return keylog('extract', HMAC_hash(salt, ikm));\n}\n\nfunction HKDF_expand(prk, info, l) {\n  keylog('prk', prk);\n  keylog('info', info);\n  var output = Buffer.alloc(0);\n  var T = Buffer.alloc(0);\n  info = Buffer.from(info, 'ascii');\n  var counter = 0;\n  var cbuf = Buffer.alloc(1);\n  while (output.length < l) {\n    cbuf.writeUIntBE(++counter, 0, 1);\n    T = HMAC_hash(prk, Buffer.concat([T, info, cbuf]));\n    output = Buffer.concat([output, T]);\n  }\n\n  return keylog('expand', output.slice(0, l));\n}\n\nfunction HKDF(salt, ikm, info, len) {\n  return HKDF_expand(HKDF_extract(salt, ikm), info, len);\n}\n\nfunction info(base, context) {\n  var result = Buffer.concat([\n    Buffer.from('Content-Encoding: ' + base + '\\0', 'ascii'),\n    context\n  ]);\n  keylog('info ' + base, result);\n  return result;\n}\n\nfunction lengthPrefix(buffer) {\n  var b = Buffer.concat([Buffer.alloc(2), buffer]);\n  b.writeUIntBE(buffer.length, 0, 2);\n  return b;\n}\n\nfunction extractDH(header, mode) {\n  var key = header.privateKey;\n  var senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = key.getPublicKey();\n    receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    senderPubKey = header.dh;\n    receiverPubKey = key.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  return {\n    secret: key.computeSecret(header.dh),\n    context: Buffer.concat([\n      Buffer.from(header.keylabel, 'ascii'),\n      Buffer.from([0]),\n      lengthPrefix(receiverPubKey), // user agent\n      lengthPrefix(senderPubKey)    // application server\n    ])\n  };\n}\n\nfunction extractSecretAndContext(header, mode) {\n  var result = { secret: null, context: Buffer.alloc(0) };\n  if (header.key) {\n    result.secret = header.key;\n    if (result.secret.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n  } else if (header.dh) { // receiver/decrypt\n    result = extractDH(header, mode);\n  } else if (typeof header.keyid !== undefined) {\n    result.secret = header.keymap[header.keyid];\n  }\n  if (!result.secret) {\n    throw new Error('Unable to determine key');\n  }\n  keylog('secret', result.secret);\n  keylog('context', result.context);\n  if (header.authSecret) {\n    result.secret = HKDF(header.authSecret, result.secret,\n                         info('auth', Buffer.alloc(0)), SHA_256_LENGTH);\n    keylog('authsecret', result.secret);\n  }\n  return result;\n}\n\nfunction webpushSecret(header, mode) {\n  if (!header.authSecret) {\n    throw new Error('No authentication secret for webpush');\n  }\n  keylog('authsecret', header.authSecret);\n\n  var remotePubKey, senderPubKey, receiverPubKey;\n  if (mode === MODE_ENCRYPT) {\n    senderPubKey = header.privateKey.getPublicKey();\n    remotePubKey = receiverPubKey = header.dh;\n  } else if (mode === MODE_DECRYPT) {\n    remotePubKey = senderPubKey = header.keyid;\n    receiverPubKey = header.privateKey.getPublicKey();\n  } else {\n    throw new Error('Unknown mode only ' + MODE_ENCRYPT +\n                    ' and ' + MODE_DECRYPT + ' supported');\n  }\n  keylog('remote pubkey', remotePubKey);\n  keylog('sender pubkey', senderPubKey);\n  keylog('receiver pubkey', receiverPubKey);\n  return keylog('secret dh',\n                HKDF(header.authSecret,\n                     header.privateKey.computeSecret(remotePubKey),\n                     Buffer.concat([\n                       Buffer.from('WebPush: info\\0'),\n                       receiverPubKey,\n                       senderPubKey\n                     ]),\n                     SHA_256_LENGTH));\n}\n\nfunction extractSecret(header, mode, keyLookupCallback) {\n  if (keyLookupCallback) {\n    if (!isFunction(keyLookupCallback)) {\n      throw new Error('Callback is not a function')\n    }\n  }\n\n  if (header.key) {\n    if (header.key.length !== KEY_LENGTH) {\n      throw new Error('An explicit key must be ' + KEY_LENGTH + ' bytes');\n    }\n    return keylog('secret key', header.key);\n  }\n\n  if (!header.privateKey) {\n    // Lookup based on keyid\n    if (!keyLookupCallback) {\n      var key = header.keymap && header.keymap[header.keyid];\n    } else {\n      var key = keyLookupCallback(header.keyid)\n    }\n    if (!key) {\n      throw new Error('No saved key (keyid: \"' + header.keyid + '\")');\n    }\n    return key;\n  }\n\n  return webpushSecret(header, mode);\n}\n\nfunction deriveKeyAndNonce(header, mode, lookupKeyCallback) {\n  if (!header.salt) {\n    throw new Error('must include a salt parameter for ' + header.version);\n  }\n  var keyInfo;\n  var nonceInfo;\n  var secret;\n  if (header.version === 'aesgcm') {\n    // old\n    var s = extractSecretAndContext(header, mode, lookupKeyCallback);\n    keyInfo = info('aesgcm', s.context);\n    nonceInfo = info('nonce', s.context);\n    secret = s.secret;\n  } else if (header.version === 'aes128gcm') {\n    // latest\n    keyInfo = Buffer.from('Content-Encoding: aes128gcm\\0');\n    nonceInfo = Buffer.from('Content-Encoding: nonce\\0');\n    secret = extractSecret(header, mode, lookupKeyCallback);\n  } else {\n    throw new Error('Unable to set context for mode ' + header.version);\n  }\n  var prk = HKDF_extract(header.salt, secret);\n  var result = {\n    key: HKDF_expand(prk, keyInfo, KEY_LENGTH),\n    nonce: HKDF_expand(prk, nonceInfo, NONCE_LENGTH)\n  };\n  keylog('key', result.key);\n  keylog('nonce base', result.nonce);\n  return result;\n}\n\n/* Parse command-line arguments. */\nfunction parseParams(params) {\n  var header = {};\n\n  header.version = params.version || 'aes128gcm';\n  header.rs = parseInt(params.rs, 10);\n  if (isNaN(header.rs)) {\n    header.rs = 4096;\n  }\n  var overhead = PAD_SIZE[header.version];\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  if (header.rs <= overhead) {\n    throw new Error('The rs parameter has to be greater than ' + overhead);\n  }\n\n  if (params.salt) {\n    header.salt = decode(params.salt);\n    if (header.salt.length !== KEY_LENGTH) {\n      throw new Error('The salt parameter must be ' + KEY_LENGTH + ' bytes');\n    }\n  }\n  header.keyid = params.keyid;\n  if (params.key) {\n    header.key = decode(params.key);\n  } else {\n    header.privateKey = params.privateKey;\n    if (!header.privateKey) {\n      header.keymap = params.keymap;\n    }\n    if (header.version !== 'aes128gcm') {\n      header.keylabel = params.keylabel || 'P-256';\n    }\n    if (params.dh) {\n      header.dh = decode(params.dh);\n    }\n  }\n  if (params.authSecret) {\n    header.authSecret = decode(params.authSecret);\n  }\n  return header;\n}\n\nfunction generateNonce(base, counter) {\n  var nonce = Buffer.from(base);\n  var m = nonce.readUIntBE(nonce.length - 6, 6);\n  var x = ((m ^ counter) & 0xffffff) +\n      ((((m / 0x1000000) ^ (counter / 0x1000000)) & 0xffffff) * 0x1000000);\n  nonce.writeUIntBE(x, nonce.length - 6, 6);\n  keylog('nonce' + counter, nonce);\n  return nonce;\n}\n\n/* Used when decrypting aes128gcm to populate the header values. Modifies the\n * header values in place and returns the size of the header. */\nfunction readHeader(buffer, header) {\n  var idsz = buffer.readUIntBE(20, 1);\n  header.salt = buffer.slice(0, KEY_LENGTH);\n  header.rs = buffer.readUIntBE(KEY_LENGTH, 4);\n  header.keyid = buffer.slice(21, 21 + idsz);\n  return 21 + idsz;\n}\n\nfunction unpadLegacy(data, version) {\n  var padSize = PAD_SIZE[version];\n  var pad = data.readUIntBE(0, padSize);\n  if (pad + padSize > data.length) {\n    throw new Error('padding exceeds block size');\n  }\n  keylog('padding', data.slice(0, padSize + pad));\n  var padCheck = Buffer.alloc(pad);\n  padCheck.fill(0);\n  if (padCheck.compare(data.slice(padSize, padSize + pad)) !== 0) {\n    throw new Error('invalid padding');\n  }\n  return data.slice(padSize + pad);\n}\n\nfunction unpad(data, last) {\n  var i = data.length - 1;\n  while(i >= 0) {\n    if (data[i]) {\n      if (last) {\n        if (data[i] !== 2) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      } else {\n        if (data[i] !== 1) {\n          throw new Error('last record needs to start padding with a 2');\n        }\n      }\n      return data.slice(0, i);\n    }\n    --i;\n  }\n  throw new Error('all zero plaintext');\n}\n\nfunction decryptRecord(key, counter, buffer, header, last) {\n  keylog('decrypt', buffer);\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createDecipheriv(AES_GCM, key.key, nonce);\n  gcm.setAuthTag(buffer.slice(buffer.length - TAG_LENGTH));\n  var data = gcm.update(buffer.slice(0, buffer.length - TAG_LENGTH));\n  data = Buffer.concat([data, gcm.final()]);\n  keylog('decrypted', data);\n  if (header.version !== 'aes128gcm') {\n    return unpadLegacy(data, header.version);\n  }\n  return unpad(data, last);\n}\n\n/**\n * Decrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.  Binary values are base64url encoded.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * If the version is aes128gcm, the keyid is extracted from the header and used\n * as the ECDH public key of the sender.  For version aesgcm ,\n * |params.dh| needs to be provided with the public key of the sender.\n *\n * The |params.privateKey| includes the private key of the receiver.\n */\nfunction decrypt(buffer, params, keyLookupCallback) {\n  var header = parseParams(params);\n  if (header.version === 'aes128gcm') {\n    var headerLength = readHeader(buffer, header);\n    buffer = buffer.slice(headerLength);\n  }\n  var key = deriveKeyAndNonce(header, MODE_DECRYPT, keyLookupCallback);\n  var start = 0;\n  var result = Buffer.alloc(0);\n\n  var chunkSize = header.rs;\n  if (header.version !== 'aes128gcm') {\n    chunkSize += TAG_LENGTH;\n  }\n\n  for (var i = 0; start < buffer.length; ++i) {\n    var end = start + chunkSize;\n    if (header.version !== 'aes128gcm' && end === buffer.length) {\n      throw new Error('Truncated payload');\n    }\n    end = Math.min(end, buffer.length);\n    if (end - start <= TAG_LENGTH) {\n      throw new Error('Invalid block: too small at ' + i);\n    }\n    var block = decryptRecord(key, i, buffer.slice(start, end),\n                              header, end >= buffer.length);\n    result = Buffer.concat([result, block]);\n    start = end;\n  }\n  return result;\n}\n\nfunction encryptRecord(key, counter, buffer, pad, header, last) {\n  keylog('encrypt', buffer);\n  pad = pad || 0;\n  var nonce = generateNonce(key.nonce, counter);\n  var gcm = crypto.createCipheriv(AES_GCM, key.key, nonce);\n\n  var ciphertext = [];\n  var padSize = PAD_SIZE[header.version];\n  var padding = Buffer.alloc(pad + padSize);\n  padding.fill(0);\n\n  if (header.version !== 'aes128gcm') {\n    padding.writeUIntBE(pad, 0, padSize);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n    ciphertext.push(gcm.update(buffer));\n\n    if (!last && padding.length + buffer.length < header.rs) {\n      throw new Error('Unable to pad to record size');\n    }\n  } else {\n    ciphertext.push(gcm.update(buffer));\n    padding.writeUIntBE(last ? 2 : 1, 0, 1);\n    keylog('padding', padding);\n    ciphertext.push(gcm.update(padding));\n  }\n\n  gcm.final();\n  var tag = gcm.getAuthTag();\n  if (tag.length !== TAG_LENGTH) {\n    throw new Error('invalid tag generated');\n  }\n  ciphertext.push(tag);\n  return keylog('encrypted', Buffer.concat(ciphertext));\n}\n\nfunction writeHeader(header) {\n  var ints = Buffer.alloc(5);\n  var keyid = Buffer.from(header.keyid || []);\n  if (keyid.length > 255) {\n    throw new Error('keyid is too large');\n  }\n  ints.writeUIntBE(header.rs, 0, 4);\n  ints.writeUIntBE(keyid.length, 4, 1);\n  return Buffer.concat([header.salt, ints, keyid]);\n}\n\n/**\n * Encrypt some bytes.  This uses the parameters to determine the key and block\n * size, which are described in the draft.\n *\n * |params.version| contains the version of encoding to use: aes128gcm is the latest,\n * but aesgcm is also accepted (though the latter two might\n * disappear in a future release).  If omitted, assume aes128gcm.\n *\n * If |params.key| is specified, that value is used as the key.\n *\n * For Diffie-Hellman (WebPush), |params.dh| includes the public key of the\n * receiver.  |params.privateKey| is used to establish a shared secret.  Key\n * pairs can be created using |crypto.createECDH()|.\n */\nfunction encrypt(buffer, params, keyLookupCallback) {  \n  if (!Buffer.isBuffer(buffer)) {\n    throw new Error('buffer argument must be a Buffer');\n  }\n  var header = parseParams(params);\n  if (!header.salt) {\n    header.salt = crypto.randomBytes(KEY_LENGTH);\n  }\n\n  var result;\n  if (header.version === 'aes128gcm') {\n    // Save the DH public key in the header unless keyid is set.\n    if (header.privateKey && !header.keyid) {\n      header.keyid = header.privateKey.getPublicKey();\n    }\n    result = writeHeader(header);\n  } else {\n    // No header on other versions\n    result = Buffer.alloc(0);\n  }\n\n  var key = deriveKeyAndNonce(header, MODE_ENCRYPT, keyLookupCallback);\n  var start = 0;\n  var padSize = PAD_SIZE[header.version];\n  var overhead = padSize;\n  if (header.version === 'aes128gcm') {\n    overhead += TAG_LENGTH;\n  }\n  var pad = isNaN(parseInt(params.pad, 10)) ? 0 : parseInt(params.pad, 10);\n\n  var counter = 0;\n  var last = false;\n  while (!last) {\n    // Pad so that at least one data byte is in a block.\n    var recordPad = Math.min(header.rs - overhead - 1, pad);\n    if (header.version !== 'aes128gcm') {\n      recordPad = Math.min((1 << (padSize * 8)) - 1, recordPad);\n    }\n    if (pad > 0 && recordPad === 0) {\n      ++recordPad; // Deal with perverse case of rs=overhead+1 with padding.\n    }\n    pad -= recordPad;\n\n    var end = start + header.rs - overhead - recordPad;\n    if (header.version !== 'aes128gcm') {\n      // The > here ensures that we write out a padding-only block at the end\n      // of a buffer.\n      last = end > buffer.length;\n    } else {\n      last = end >= buffer.length;\n    }\n    last = last && pad <= 0;\n    var block = encryptRecord(key, counter, buffer.slice(start, end),\n                              recordPad, header, last);\n    result = Buffer.concat([result, block]);\n\n    start = end;\n    ++counter;\n  }\n  return result;\n}\n\n\nfunction isFunction(object) {\n  return typeof(object) === 'function';\n }\n\nmodule.exports = {\n  decrypt: decrypt,\n  encrypt: encrypt\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}